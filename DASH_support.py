#! /usr/bin/env python
#
# Support module generated by PAGE version 4.6
# In conjunction with Tcl version 8.6
#    Mar 06, 2016 10:02:21 PM
#
# This file is used for holding all the underlying functions that the GUI uses
# when buttons are pressed.


import sys
import DASH
import serial   # Download and install PySerial for this library
import glob
import sys
import timeit
from string import join


# The following try statements are for determining if Python 2.7 or 3 are used
try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1

# All the serial communication will be done via Bluetooth so BT will be our serial port variable
BT = serial.Serial()


def set_Tk_var():
    # These are Tk variables used passed to Tkinter and must be
    # defined before the widgets using them are created.
    global combobox
    combobox = StringVar()


def serial_ports():
    """ Lists serial port names

        :raises EnvironmentError:
            On unsupported or unknown platforms
        :returns:
            A list of the serial ports available on the system
    """
    if sys.platform.startswith('win'):
        ports = ['COM%s' % (i + 1) for i in range(256)]
    elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
        # this excludes your current terminal "/dev/tty"
        ports = glob.glob('/dev/tty[A-Za-z]*')
    elif sys.platform.startswith('darwin'):
        ports = glob.glob('/dev/tty.*')
    else:
        raise EnvironmentError('Unsupported platform')

    result = []
    for port in ports:
        try:
            s = serial.Serial(port)
            s.close()
            result.append(port)
        except (OSError, serial.SerialException):
            pass
    return result

# In conCom we initialize the serial Bluetooth connection
def conCOM(p1):
    ports = p1.comSelect.get()
    BT.port = ports
    BT.baudrate = 921600
    BT.timeout = 3
    BT.open()
    p1.listBox.insert(END, "Connected")
    p1.listBox.see(END)
    sys.stdout.flush()


# Scans the available ports on the computer and displays them in a drop down list
def portScan(p1):
    ports = serial_ports()
    p1.comSelect.configure(values=ports)
    p1.comSelect.current(0)
    sys.stdout.flush()


# Turns the DASH to the right by reversing the right legs while the left legs remain
# moving in the forward direction.
def rght(p1):
    biteOne = chr(0b10100000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Right \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


# Reverses the DASH
def rvrs(p1):
    biteOne = chr(0b10000000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Reverse \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


# Sets the DASH moving in the forward direction
def fwd(p1):
    biteOne = chr(0b11100000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    print("pressed")
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Forward \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


# Turns the DASH to the left by reversing the left set of legs while
# the right legs continue moving in the forward direction.
def lft(p1):
    biteOne = chr(0b11000000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Forward \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


# Stops the DASH by setting the power to the motors to zero
def stop(p1):
    biteOne = chr(0b11100000)
    biteTwo = chr(0b00000000)
    biteThree = chr(0b00000000)
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Stop \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


# Initializes the GUI
def init(top, gui, arg=None):
    global w, top_level, root
    w = gui
    top_level = top
    root = top


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


# Takes the 4 bytes of the move commands and joins in an array
# them then sends them to the DASH.
def mvcmd(p1, b1, b2, b3, b4):
    bitearray = [b1, b2, b3, b4]
    message = "".join(bitearray)
    print(bitearray)
    BT.write(message)
    bread = BT.read(2)
    return bread


# Prints the byte segments for seeing what was sent to the DASH
def prntBS(p1, b1, b2, b3, b4):
    p1.listBox.insert(END, "Byte 1: " + hex(ord(b1)) + "\n")
    p1.listBox.insert(END, "Byte 2: " + hex(ord(b2)) + "\n")
    p1.listBox.insert(END, "Byte 3: " + hex(ord(b3)) + "\n")
    p1.listBox.insert(END, "Byte 4: " + hex(ord(b4)) + "\n")


# Prints in the window what power and command was sent to the DASH
def prnt_command(p1, pwrcom):
    if pwrcom:
        p1.listBox.insert(END, ">" + p1.txtCommand.get() + " Power: " +
                          str(p1.dutyCycleLeft.get()) + " " + str(p1.dutyCycleRight.get()) + "\n")
    else:
        p1.listBox.insert(END, ">" + p1.txtCommand.get() + "\n")
    p1.listBox.see(END)


# List of commands that the GUI recognizes for control of the DASH
def prnt_help(p1):
    p1.listBox.insert(END, 'LIST OF COMMANDS:(commands are case insensitive)',
                      "Forward - DASH moves forward with power from slider",
                      'Reverse - DASH moves backward with power from slider',
                      'Right - DASH turns to the right',
                      'Left - DASH turns to the left',
                      'Stop - DASH stops',
                      'Set - Used for adjusting motor speed')


# Sets the position of the legs by reading the numerical inputs in the position
# boxes and then sending the values to the DASH to move the legs to that point.
def posSet(p1):
    left = p1.leftPosCom.get()
    right = p1.rightPosCom.get()
    biteOne = chr(0b01100000)
    biteTwo = chr(int(left))
    biteThree = chr(int(right))
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.txtCommand.focus_set()
    p1.listBox.see(END)
    sys.stdout.flush()


# Requests the positon of the legs to be sent
def posGet(p1):
    bitearray = [0x10] * 4
    BT.write(bitearray)
    bread = BT.read(4)
    p1.listBox.insert(END, bread[0] + bread[1] + " Left: " + str(ord(bread[2])) +
                      " Right: " + str(ord(bread[3])) + "\n")
    p1.txtCommand.focus_set()
    p1.txtCommand.delete(0, END)
    p1.listBox.see(END)
    sys.stdout.flush()


# Reads in commands and checks if the command is valid.
# If the command is valid it will execute the command, however, if the command
# is not valid it will print an unrecognized command error.
def goDASH(p1):
    cmd = p1.txtCommand.get()
    if cmd.lower() == 'set':
        prnt_command(p1, 1)
        BT.write(str(unichr(p1.dutyCycleRight.get())))
        bread = BT.read(1)
        print(p1.dutyCycle.get())
    elif cmd.lower() == 'forward':
        biteOne = chr(0b11100000)
        biteTwo = chr(p1.dutyCycleLeft.get())
        biteThree = chr(p1.dutyCycleRight.get())
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        prnt_command(p1, 1)
        prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'reverse':
        biteOne = chr(0b10000000)
        biteTwo = chr(p1.dutyCycleLeft.get())
        biteThree = chr(p1.dutyCycleRight.get())
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        prnt_command(p1, 1)
        prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'right':
        biteOne = chr(0b10100000)
        biteTwo = chr(p1.dutyCycleLeft.get())
        biteThree = chr(p1.dutyCycleRight.get())
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "> Right \n")
        prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'left':
        biteOne = chr(0b11000000)
        biteTwo = chr(p1.dutyCycleLeft.get())
        biteThree = chr(p1.dutyCycleRight.get())
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "> Forward \n")
        prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'stop':
        biteOne = chr(0b10000000)
        biteTwo = chr(0b00000000)
        biteThree = chr(0b00000000)
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        prnt_command(p1, 0)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'help':
        prnt_help(p1)
    elif cmd.isdigit():
        print(int(p1.txtCommand.get()) % 192)
    elif cmd.lower() == 'test':
        count = 1
        bitearray = [0xFE] * 10000
        # message = "".join(bitearray)
        start = timeit.default_timer()
        BT.write(bitearray)
        bread = BT.read(9000)
        finish = timeit.default_timer() - start
        latency = (finish/9000)*1000
        print(len(bread))
        p1.listBox.insert(END, "10000 Bytes sent\n")
        p1.listBox.insert(END, "Round Trip Time: " + str(finish*1000) + "ms\n")
        p1.listBox.insert(END, "Round Trip Time per Byte: " + str(latency) + "ms\n")
        p1.listBox.insert(END, "Response Time: " + str(latency/2) + "ms\n")
    elif cmd.lower() == 'data':
        count = 1
        bitearray = [0xFE] * 10000
        # message = "".join(bitearray)
        start = timeit.default_timer()
        BT.write(bitearray)
        bread = BT.read(9000)
        finish = timeit.default_timer() - start
        latency = ((finish/9000)*1000/2)
        p1.listBox.insert(END, "10000 Bytes sent\n")
        p1.listBox.insert(END, "Latency: " + str(latency*2) + "ms\n")
        p1.listBox.insert(END, "Datarate: " + str(1/(latency/8)) + "Kbps\n")
    elif cmd.lower() == 'position':
        bitearray = [0x10] * 4
        BT.write(bitearray)
        bread = BT.read(4)
        p1.listBox.insert(END, bread[0] + bread[1] + " Left: " + str(ord(bread[2])) +
                          " Right: " + str(ord(bread[3])) + "\n")
    else:
        p1.listBox.insert(END, "Unknown Command: " + p1.txtCommand.get())
    p1.txtCommand.focus_set()
    p1.txtCommand.delete(0, END)
    p1.listBox.see(END)
    sys.stdout.flush()


if __name__ == '__main__':
    import DASH
    DASH.vp_start_gui()
