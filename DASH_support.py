#! /usr/bin/env python
#
# Support module generated by PAGE version 4.6
# In conjunction with Tcl version 8.6
#    Mar 06, 2016 10:02:21 PM


import sys
import DASH
import serial
import glob
import sys
import timeit
from string import join

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1

BT = serial.Serial()


def set_Tk_var():
    # These are Tk variables used passed to Tkinter and must be
    # defined before the widgets using them are created.
    global combobox
    combobox = StringVar()


def serial_ports():
    """ Lists serial port names

        :raises EnvironmentError:
            On unsupported or unknown platforms
        :returns:
            A list of the serial ports available on the system
    """
    if sys.platform.startswith('win'):
        ports = ['COM%s' % (i + 1) for i in range(256)]
    elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
        # this excludes your current terminal "/dev/tty"
        ports = glob.glob('/dev/tty[A-Za-z]*')
    elif sys.platform.startswith('darwin'):
        ports = glob.glob('/dev/tty.*')
    else:
        raise EnvironmentError('Unsupported platform')

    result = []
    for port in ports:
        try:
            s = serial.Serial(port)
            s.close()
            result.append(port)
        except (OSError, serial.SerialException):
            pass
    return result


def conCOM(p1):
    ports = p1.comSelect.get()
    BT.port = ports
    BT.baudrate = 921600
    BT.timeout = 3
    BT.open()
    print(BT.isOpen())
    p1.listBox.insert(END, "Connected")
    p1.listBox.see(END)
    sys.stdout.flush()


def portScan(p1):
    ports = serial_ports()
    p1.comSelect.configure(values=ports)
    p1.comSelect.current(0)
    sys.stdout.flush()


def rght(p1):
    biteOne = chr(0b10100000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Right \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def rvrs(p1):
    biteOne = chr(0b10000000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Reverse \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def fwd(p1):
    biteOne = chr(0b11100000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Forward \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def lft(p1):
    biteOne = chr(0b11000000)
    biteTwo = chr(p1.dutyCycleLeft.get())
    biteThree = chr(p1.dutyCycleRight.get())
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Forward \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def stop(p1):
    biteOne = chr(0b11100000)
    biteTwo = chr(0b00000000)
    biteThree = chr(0b00000000)
    biteFour = chr(0b00000000)
    bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "> Stop \n")
    prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
    p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def init(top, gui, arg=None):
    global w, top_level, root
    w = gui
    top_level = top
    root = top


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


def mvcmd(p1, b1, b2, b3, b4):
    bitearray = [b1, b2, b3, b4]
    message = "".join(bitearray)
    print(bitearray)
    BT.write(message)
    bread = BT.read(2)
    return bread


def prntBS(p1, b1, b2, b3, b4):
    p1.listBox.insert(END, "Byte 1: " + hex(ord(b1)) + "\n")
    p1.listBox.insert(END, "Byte 2: " + hex(ord(b2)) + "\n")
    p1.listBox.insert(END, "Byte 3: " + hex(ord(b3)) + "\n")
    p1.listBox.insert(END, "Byte 4: " + hex(ord(b4)) + "\n")


def prnt_command(p1, pwrcom):
    if pwrcom:
        p1.listBox.insert(END, ">" + p1.txtCommand.get() + " Power: " +
                          str(p1.dutyCycleLeft.get()) + " " + str(p1.dutyCycleRight.get()) + "\n")
    else:
        p1.listBox.insert(END, ">" + p1.txtCommand.get() + "\n")
    p1.listBox.see(END)


def prnt_help(p1):
    p1.listBox.insert(END, 'LIST OF COMMANDS:(commands are case insensitive)',
                      "Forward - DASH moves forward with power from slider",
                      'Reverse - DASH moves backward with power from slider',
                      'Right - DASH turns to the right',
                      'Left - DASH turns to the left',
                      'Stop - DASH stops',
                      'Set - Used for adjusting motor speed')



def goDASH(p1):
    cmd = p1.txtCommand.get()
    if cmd.lower() == 'set':
        prnt_command(p1, 1)
        BT.write(str(unichr(p1.dutyCycleRight.get())))
        bread = BT.read(1)
        print(p1.dutyCycle.get())
    elif cmd.lower() == 'forward':
        biteOne = chr(0b11100000)
        biteTwo = chr(p1.dutyCycleLeft.get())
        biteThree = chr(p1.dutyCycleRight.get())
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        prnt_command(p1, 1)
        prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'reverse':
        biteOne = chr(0b10000000)
        biteTwo = chr(p1.dutyCycleLeft.get())
        biteThree = chr(p1.dutyCycleRight.get())
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        prnt_command(p1, 1)
        prntBS(p1, biteOne, biteTwo, biteThree, biteFour)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'right':
        prnt_command(p1, 0)
        print('Right')
    elif cmd.lower() == 'left':
        prnt_command(p1, 0)
        print('Left')
    elif cmd.lower() == 'stop':
        biteOne = chr(0b10000000)
        biteTwo = chr(0b00000000)
        biteThree = chr(0b00000000)
        biteFour = chr(0b00000000)
        bread = mvcmd(p1, biteOne, biteTwo, biteThree, biteFour)
        prnt_command(p1, 0)
        p1.listBox.insert(END, "DASH Response: " + bread + "\n")
    elif cmd.lower() == 'help':
        prnt_help(p1)
    elif cmd.isdigit():
        print(int(p1.txtCommand.get()) % 192)
    elif cmd.lower() == 'test':
        count = 1
        bitearray = [0xFE] * 10000
        print(bitearray)
        # message = "".join(bitearray)
        start = timeit.default_timer()
        BT.write(bitearray)
        bread = BT.read(9000)
        finish = timeit.default_timer() - start
        latency = (finish/9000)*1000
        print(len(bread))
        p1.listBox.insert(END, "10000 Bytes sent\n")
        p1.listBox.insert(END, "Round Trip Time: " + str(finish*1000) + "ms\n")
        p1.listBox.insert(END, "Round Trip Time per Byte: " + str(latency) + "ms\n")
        p1.listBox.insert(END, "Response Time: " + str(latency/2) + "ms\n")
    elif cmd.lower() == 'data':
        count = 1
        bitearray = [0xFE] * 10000
        print(bitearray)
        # message = "".join(bitearray)
        start = timeit.default_timer()
        BT.write(bitearray)
        bread = BT.read(9000)
        finish = timeit.default_timer() - start
        latency = ((finish/9000)*1000)/2
        p1.listBox.insert(END, "10000 Bytes sent\n")
        p1.listBox.insert(END, "Datarate: " + str(1/(latency/8)) + "Kbps\n")
    elif cmd.lower() == 'latency':
        start = timeit.default_timer()
        BT.write("12345678901234567890123456789012345678901234567890")
        bread = BT.read(50)
        finish = timeit.default_timer() - start
        latency = (finish/50)*1000
        p1.listBox.insert(END, "Latency: " + str(latency) + "ms\n")
        print(bread)
    elif cmd.lower() == 'feedback':
        BT.write("?")
        bread = BT.read(2)
        p1.listBox.insert(END, bread + "\n")
    else:
        p1.listBox.insert(END, "Unknown Command: " + p1.txtCommand.get())
    p1.txtCommand.focus_set()
    p1.txtCommand.delete(0, END)
    p1.listBox.see(END)
    sys.stdout.flush()


if __name__ == '__main__':
    import DASH
    DASH.vp_start_gui()
