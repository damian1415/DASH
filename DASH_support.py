#! /usr/bin/env python
#
# Support module generated by PAGE version 4.6
# In conjunction with Tcl version 8.6
#    Mar 06, 2016 10:02:21 PM


import sys
import DASH
import serial
import glob
import sys
import timeit
from string import join

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1

BT = serial.Serial()


def set_Tk_var():
    # These are Tk variables used passed to Tkinter and must be
    # defined before the widgets using them are created.
    global combobox
    combobox = StringVar()


def serial_ports():
    """ Lists serial port names

        :raises EnvironmentError:
            On unsupported or unknown platforms
        :returns:
            A list of the serial ports available on the system
    """
    if sys.platform.startswith('win'):
        ports = ['COM%s' % (i + 1) for i in range(256)]
    elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
        # this excludes your current terminal "/dev/tty"
        ports = glob.glob('/dev/tty[A-Za-z]*')
    elif sys.platform.startswith('darwin'):
        ports = glob.glob('/dev/tty.*')
    else:
        raise EnvironmentError('Unsupported platform')

    result = []
    for port in ports:
        try:
            s = serial.Serial(port)
            s.close()
            result.append(port)
        except (OSError, serial.SerialException):
            pass
    return result


def conCOM(p1):
    ports = p1.comSelect.get()
    BT.port = ports
    BT.baudrate = 115200
    BT.timeout = 1
    BT.open()
    print(BT.isOpen())
    p1.listBox.insert(END, "Connected")
    p1.listBox.see(END)
    sys.stdout.flush()


def portScan(p1):
    ports = serial_ports()
    p1.comSelect.configure(values=ports)
    p1.comSelect.current(0)
    sys.stdout.flush()


def rght(p1):
    print('DASH_support.rght')
    p1.listBox.insert(END, "> Right" + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def rvrs(p1):
    print('DASH_support.rvrs')
    p1.listBox.insert(END, "> Reverse" + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def fwd(p1):
    print('DASH_support.fwd')
    p1.listBox.insert(END, "> Forward" + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def lft(p1):
    print('DASH_support.lft')
    p1.listBox.insert(END, "> Left" + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def stop(p1):
    print('DASH_support.stop')
    p1.listBox.insert(END, "> Stop" + "\n")
    p1.listBox.see(END)
    sys.stdout.flush()


def init(top, gui, arg=None):
    global w, top_level, root
    w = gui
    top_level = top
    root = top


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


def prnt_command(p1, pwrcom):
    if pwrcom:
        p1.listBox.insert(END, ">" + p1.txtCommand.get() + " Power: " + str(p1.dutyCycleLeft.get()) + "\n")
    else:
        p1.listBox.insert(END, ">" + p1.txtCommand.get() + "\n")


def prnt_help(p1):
    p1.listBox.insert(END, 'LIST OF COMMANDS:(commands are case insensitive)',
                      "Forward - DASH moves forward with power from slider",
                      'Reverse - DASH moves backward with power from slider',
                      'Right - DASH turns to the right',
                      'Left - DASH turns to the left',
                      'Stop - DASH stops',
                      'Set - Used for adjusting motor speed')



def goDASH(p1):
    cmd = p1.txtCommand.get()
    if cmd.lower() == 'set':
        prnt_command(p1, 1)
        BT.write(str(unichr(p1.dutyCycleRight.get())))
        bread = BT.read(1)
        print(p1.dutyCycle.get())
    elif cmd.lower() == 'forward':
        biteOne = chr(0b11100000)
        biteTwo = chr(p1.dutyCycleLeft.get())
        biteThree = chr(p1.dutyCycleRight.get())
        biteFour = chr(0b00000000)
        biteArray = [biteOne, biteTwo, biteThree, biteFour]
        message = "".join(biteArray)
        BT.write(message)
        bread = BT.read(2)
        left = ord(bread[1])
        prnt_command(p1, 1)
        p1.listBox.insert(END, str(left) + "\n")
    elif cmd.lower() == 'reverse':
        prnt_command(p1, 1)
        print('Reverse')
    elif cmd.lower() == 'right':
        prnt_command(p1, 0)
        print('Right')
    elif cmd.lower() == 'left':
        prnt_command(p1, 0)
        print('Left')
    elif cmd.lower() == 'stop':
        prnt_command(p1, 0)
        print('Stop')
    elif cmd.lower() == 'help':
        prnt_help(p1)
    elif cmd.isdigit():
        print(int(p1.txtCommand.get()) % 192)
    elif cmd.lower() == 'test':
        start = timeit.default_timer()
        count = 0
        while count < 100:
            BT.write(str(unichr(count)))
            count += 1
        mid = timeit.default_timer() - start
        bread = BT.read(100)
        finish = timeit.default_timer() - start
        triptime = finish/2
        datarate = 1/triptime
        p1.listBox.insert(END, bread)
        print(start)
        print(mid)
        print(finish)
        print(bread)
        print(datarate)
    elif cmd.lower() == 'latency':
        start = timeit.default_timer()
        BT.write("12345678901234567890123456789012345678901234567890")
        bread = BT.read(50)
        finish = timeit.default_timer() - start
        latency = (finish/50)*1000
        p1.listBox.insert(END, "Latency: " + str(latency) + "ms\n")
    elif cmd.lower() == 'feedback':
        BT.write("?")
        bread = BT.read(2)
        p1.listBox.insert(END, bread + "\n")
    else:
        p1.listBox.insert(END, "Unknown Command: " + p1.txtCommand.get())
    p1.txtCommand.focus_set()
    p1.txtCommand.delete(0, END)
    p1.listBox.see(END)
    sys.stdout.flush()


if __name__ == '__main__':
    import DASH
    DASH.vp_start_gui()
